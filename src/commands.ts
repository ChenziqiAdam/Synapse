import { Editor, TFile, Notice, App, MarkdownView } from 'obsidian';
import { OllamaClient } from './ollama';
import { SynapseSettings } from './settings';

export class SynapseCommands {
    private app: App;
    private ollama: OllamaClient;
    private settings: SynapseSettings;

    constructor(app: App, ollama: OllamaClient, settings: SynapseSettings) {
        this.app = app;
        this.ollama = ollama;
        this.settings = settings;
    }

    updateSettings(settings: SynapseSettings) {
        this.settings = settings;
        this.ollama = new OllamaClient(settings.ollamaUrl, settings.ollamaModel);
    }

    async explainAndLink(editor: Editor, selectedText: string): Promise<void> {
        if (!selectedText.trim()) {
            new Notice('Please select text to explain');
            return;
        }

        const noticeLoading = new Notice('Generating explanation...', 0);
        
        try {
            // Generate explanation
            const systemPrompt = `You are a helpful educational assistant. Create a clear, concise explanation of the given concept. 
            Format your response as a well-structured note with:
            1. A brief definition
            2. Key characteristics or properties
            3. A simple analogy or example if helpful
            4. Why this concept is important
            
            Keep the explanation under ${this.settings.maxResponseLength} characters and use clear, educational language.`;
            
            const prompt = `Explain this concept: "${selectedText}"`;
            const explanation = await this.ollama.generate(prompt, systemPrompt);

            // Create note filename (sanitize)
            const noteTitle = this.sanitizeFileName(selectedText);
            
            // Create folder if it doesn't exist
            await this.ensureFolderExists(this.settings.explanationFolder);
            
            // Create path with folder
            const filePath = `${this.settings.explanationFolder}/${noteTitle}.md`;

            // Check if note already exists
            const existingFile = this.app.vault.getAbstractFileByPath(filePath);
            if (existingFile instanceof TFile) {
                new Notice(`Note "${noteTitle}" already exists`);
                noticeLoading.hide();
                return;
            }

            // Create new note content
            const noteContent = `# ${noteTitle}

${explanation}

---
*Generated by Synapse AI*
*Created: ${new Date().toLocaleDateString()}*`;

            // Create the new note
            const newFile = await this.app.vault.create(filePath, noteContent);

            // Insert link in current editor
            const link = `[[${filePath.replace('.md', '')}|${noteTitle}]]`;
            editor.replaceSelection(link);

            // Open the new note
            await this.app.workspace.getLeaf().openFile(newFile);

            noticeLoading.hide();
            new Notice(`Created and linked note: ${noteTitle}`);

        } catch (error) {
            noticeLoading.hide();
            new Notice(`Error: ${error.message}`);
            console.error('Explain and Link error:', error);
        }
    }

    async summarizeNote(editor: Editor, content: string): Promise<void> {
        if (!content.trim()) {
            new Notice('No content to summarize');
            return;
        }

        const noticeLoading = new Notice('Generating summary...', 0);

        try {
            const systemPrompt = `You are a helpful assistant that creates concise summaries. 
            Create a bullet-point summary (3-5 points) of the main ideas in the given text. 
            Each bullet point should be clear and capture a key concept.
            Format as markdown bullets starting with "- ".`;

            const prompt = `Summarize this content:\n\n${content}`;
            const summary = await this.ollama.generate(prompt, systemPrompt);

            // Format summary based on settings
            let summarySection;
            
            if (this.settings.useSummaryYaml) {
                // Format as YAML
                summarySection = `---
summary:
${summary.split('\n').map(line => `  ${line}`).join('\n')}
---

`;
            } else {
                // Format as regular markdown
                summarySection = `## Summary

${summary}

---

`;
            }

            // Insert summary at specified location
            if (this.settings.summaryLocation === 'top') {
                // Find first heading or insert at beginning
                const lines = content.split('\n');
                let insertIndex = 0;
                
                // Skip front matter if exists
                if (lines[0]?.startsWith('---')) {
                    let endFrontMatter = lines.findIndex((line, i) => i > 0 && line.startsWith('---'));
                    if (endFrontMatter !== -1) {
                        insertIndex = endFrontMatter + 1;
                    }
                }

                // If we're using YAML and there's already frontmatter, we need to merge them
                if (this.settings.useSummaryYaml && lines[0]?.startsWith('---')) {
                    const endFrontMatter = lines.findIndex((line, i) => i > 0 && line.startsWith('---'));
                    if (endFrontMatter !== -1) {
                        // Extract existing frontmatter
                        const existingFrontmatter = lines.slice(0, endFrontMatter + 1).join('\n');
                        // Remove closing delimiter
                        const openFrontmatter = existingFrontmatter.replace(/---\s*$/, '');
                        // Add summary to frontmatter
                        const summaryYaml = `summary:
${summary.split('\n').map(line => `  ${line}`).join('\n')}
---`;
                        // Combine
                        const newContent = openFrontmatter + summaryYaml + '\n\n' + lines.slice(endFrontMatter + 1).join('\n');
                        editor.setValue(newContent);
                        noticeLoading.hide();
                        new Notice('Summary added to frontmatter');
                        return;
                    }
                }

                const newContent = [
                    ...lines.slice(0, insertIndex),
                    '',
                    summarySection,
                    ...lines.slice(insertIndex)
                ].join('\n');

                editor.setValue(newContent);
            } else {
                // Insert at bottom
                editor.setValue(content + '\n\n' + summarySection);
            }

            noticeLoading.hide();
            new Notice('Summary added to note');

        } catch (error) {
            noticeLoading.hide();
            new Notice(`Error: ${error.message}`);
            console.error('Summarize error:', error);
        }
    }

    async createFlashcards(editor: Editor, selectedText: string): Promise<void> {
        if (!selectedText.trim()) {
            new Notice('Please select text to create flashcards from');
            return;
        }

        const noticeLoading = new Notice('Creating flashcards...', 0);

        try {
            const systemPrompt = `You are a helpful assistant that creates study flashcards. 
            From the given text, identify 3-7 key concepts and create flashcards in this exact format:

            **Q:** Question here?
            **A:** Answer here

            Make questions clear and specific. Answers should be concise but complete.
            Focus on the most important concepts for learning and retention.`;

            const prompt = `Create flashcards from this content:\n\n${selectedText}`;
            const flashcards = await this.ollama.generate(prompt, systemPrompt);

            // Decide if we should create a new flashcard note or insert into current note
            const activeFile = this.app.workspace.getActiveFile();
            const noteTitle = activeFile ? activeFile.basename : "Untitled";
            
            // Create flashcards note in dedicated folder
            await this.ensureFolderExists(this.settings.flashcardFolder);
            const flashcardFileName = `${this.settings.flashcardFolder}/${noteTitle} - Flashcards.md`;
            
            const flashcardContent = `# Flashcards for ${noteTitle}

${flashcards}

---
*Generated from: [[${activeFile ? activeFile.path.replace('.md', '') : 'Unknown source'}]]*
*Created: ${new Date().toLocaleDateString()}*
`;

            // Check if flashcard file exists and append or create
            const existingFile = this.app.vault.getAbstractFileByPath(flashcardFileName);
            
            if (existingFile instanceof TFile) {
                // Append to existing file
                const existingContent = await this.app.vault.read(existingFile);
                const newContent = existingContent + "\n\n## New Flashcards\n\n" + flashcards;
                await this.app.vault.modify(existingFile, newContent);
                
                // Open the file
                await this.app.workspace.getLeaf().openFile(existingFile);
                
                noticeLoading.hide();
                new Notice('Added flashcards to existing note');
            } else {
                // Create new file
                const newFile = await this.app.vault.create(flashcardFileName, flashcardContent);
                
                // Open the file
                await this.app.workspace.getLeaf().openFile(newFile);
                
                noticeLoading.hide();
                new Notice('Created new flashcards note');
            }

            // Also add link to current note
            const link = `\n\n[[${flashcardFileName.replace('.md', '')}|Flashcards for this note]]\n`;
            const cursor = editor.getCursor();
            editor.setLine(cursor.line, editor.getLine(cursor.line) + link);

        } catch (error) {
            noticeLoading.hide();
            new Notice(`Error: ${error.message}`);
            console.error('Create Flashcards error:', error);
        }
    }

    async startChatSession(editor: Editor): Promise<void> {
        // Create a new chat note in the chat folder
        await this.ensureFolderExists(this.settings.chatFolder);
        
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const chatFileName = `${this.settings.chatFolder}/Chat-${timestamp}.md`;
        
        const chatTemplate = `# Chat Session ${new Date().toLocaleString()}

## Context
*This is a chat session with Synapse AI. Type your messages after the > prompt.*

## Chat

> 

`;
        
        const newFile = await this.app.vault.create(chatFileName, chatTemplate);
        
        // Open the file
        const leaf = this.app.workspace.getLeaf();
        await leaf.openFile(newFile);
        
        // Position cursor at the prompt
        const newEditor = this.getActiveEditor();
        if (newEditor) {
            const lines = chatTemplate.split('\n');
            const promptLine = lines.findIndex(line => line === '> ');
            if (promptLine !== -1) {
                newEditor.setCursor({ line: promptLine, ch: 2 });
                newEditor.focus();
            }
        }
        
        new Notice('Started new chat session');
    }

    async sendChatMessage(editor: Editor): Promise<void> {
        // Find the current chat message (line starting with '>')
        const content = editor.getValue();
        const lines = content.split('\n');
        const currentLine = editor.getCursor().line;
        
        // Locate the prompt
        let promptLine = currentLine;
        while (promptLine >= 0 && !lines[promptLine].startsWith('>')) {
            promptLine--;
        }
        
        if (promptLine < 0) {
            new Notice('No chat prompt found. Please start message with >');
            return;
        }
        
        // Extract message
        const userMessage = lines[promptLine].substring(2).trim();
        if (!userMessage) {
            new Notice('Please type a message first');
            return;
        }
        
        // Update the chat with the user message
        lines[promptLine] = `> ${userMessage}`;
        
        // Add a loading indicator
        lines.splice(promptLine + 1, 0, '\n_Synapse is thinking..._');
        editor.setValue(lines.join('\n'));
        
        // Get chat history for context
        const chatHistory = this.extractChatHistory(lines, promptLine);
        
        try {
            // Generate response
            const systemPrompt = `You are a helpful AI assistant in a chat session. 
            Provide thoughtful, concise responses to the user's questions.
            Use markdown formatting when appropriate.
            Reference prior messages in the conversation when relevant.`;
            
            const response = await this.ollama.generate(userMessage, systemPrompt, chatHistory);
            
            // Remove loading indicator
            lines.splice(promptLine + 1, 1);
            
            // Add AI response and new prompt
            lines.splice(promptLine + 1, 0, 
                `\n${response}\n`,
                `> `
            );
            
            editor.setValue(lines.join('\n'));
            
            // Set cursor to new prompt
            editor.setCursor({ line: promptLine + 3, ch: 2 });
            editor.focus();
        } catch (error) {
            new Notice(`Error: ${error.message}`);
            console.error('Chat error:', error);
            
            // Remove loading indicator and add error message
            lines.splice(promptLine + 1, 1);
            lines.splice(promptLine + 1, 0, '_Error: Could not generate response_');
            editor.setValue(lines.join('\n'));
        }
    }
    
    async generateLiveSuggestion(editor: Editor): Promise<void> {
        if (!this.settings.enableLiveSuggestions) return;
        
        // Get current context
        const content = editor.getValue();
        const cursor = editor.getCursor();
        const currentLine = cursor.line;
        
        // Get a few lines before current line for context
        const contextLines = content.split('\n').slice(Math.max(0, currentLine - 10), currentLine + 1);
        const context = contextLines.join('\n');
        
        if (context.trim().length < 10) return; // Not enough context
        
        try {
            // Generate suggestion
            const systemPrompt = `You are an AI writing assistant. 
            Based on the context provided, suggest a brief continuation (1-2 sentences max).
            Make your suggestion directly relevant to what's being written.
            Do not repeat what's already written.`;
            
            const response = await this.ollama.generate(`Continue this text: ${context}`, systemPrompt);
            
            // Display suggestion as ghost text or notice
            // This would typically be implemented through a more complex UI component
            // For now, we'll use a notice
            new Notice(`Suggestion: ${response.substring(0, 100)}${response.length > 100 ? '...' : ''}`, 5000);
        } catch (error) {
            console.error('Suggestion error:', error);
        }
    }

    private sanitizeFileName(text: string): string {
        // Remove or replace invalid characters for file names
        return text
            .replace(/[^\w\s-]/g, '') // Remove special characters except word chars, spaces, hyphens
            .replace(/\s+/g, ' ') // Replace multiple spaces with single space
            .trim()
            .substring(0, 50); // Limit length
    }
    
    private async ensureFolderExists(folderPath: string): Promise<void> {
        if (!folderPath) return;
        
        const folders = folderPath.split('/').filter(p => p.trim());
        let currentPath = '';
        
        for (const folder of folders) {
            currentPath = currentPath ? `${currentPath}/${folder}` : folder;
            if (!this.app.vault.getAbstractFileByPath(currentPath)) {
                try {
                    await this.app.vault.createFolder(currentPath);
                } catch (error) {
                    console.error(`Failed to create folder ${currentPath}:`, error);
                }
            }
        }
    }
    
    private getActiveEditor(): Editor | null {
        const view = this.app.workspace.getActiveViewOfType(MarkdownView);
        return view?.editor || null;
    }
    
    private extractChatHistory(lines: string[], currentPromptLine: number): string {
        // Extract all previous exchanges to give context to the AI
        let chatHistory = '';
        let inChat = false;
        
        for (let i = 0; i < currentPromptLine; i++) {
            const line = lines[i];
            
            // Check if we've reached the chat section
            if (line === '## Chat') {
                inChat = true;
                continue;
            }
            
            if (inChat) {
                if (line.startsWith('> ')) {
                    chatHistory += `User: ${line.substring(2)}\n`;
                } else if (line.trim() && !line.startsWith('_') && line !== '') {
                    chatHistory += `AI: ${line}\n`;
                }
            }
        }
        
        return chatHistory;
    }
}